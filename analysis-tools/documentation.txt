Analysis Tools Documentation 
****************************

This directory contains (or will contain) a collection of tools for analyzing, 
formatting, and visualizing antenna pattern measurments.



Summary of Tools
****************

plotPoincare.m
*   Matlab function to plot orthogonal field measurments on a Poincare sphere to
*   visualize polarization.

findBeamwidth.m
*	Matlab function to find the desired beamwidth of an antenna pattern.

SphToRect.m
*	Matlab function to convert from spherical to rectangular coordinates.

test_findBeamwith.m
*	Matlab script to test functionality of findBeamwithd.m




Detailed Listing
****************

plotPoincare.m
*   Matlab function
*   plotPoincare(MagX, MagY, DeltaPhase, OpaqueSphere, ShowLabels)
*   
*   Plots a point or vector of points on a Poincare sphere for
*   easy visualization of the points' polarization.
*   
*   X and Y must be two perpendicular measurements of the field, with MagX
*   and MagY being the fields' magnitudes and DeltaPhase being the
*   difference in their phases in degrees (PhaseY - PhaseX).
*
*   OpaqueSphere is an optional argument which determines if the sphere is
*   opaque (points on the back are hidden) or transparent (see-through wire
*   frame) If not specified, it defaults to false (transparent).
*   
*   ShowLabels is an optional argument which sets whether or not to include
*   text labels on the sphere denoting six special case polarizations:
*   left- and right-handed circular; vertical, horizontal, and +/-45
*   degree (slant) linear. If not specified, it defaults to true.


findBeamwidth.m
*	Matlab function
*	[beamwidth, topIndex, botIndex, maxIndex]
*			= findBeamwidth(beamwidthDepth_dB, data_dB, averagingWindowSize)
*
*	Determine beamwidth of an antenna pattern.
*
*   beamwidth = Width of beam, in number of indicies between the two bounds
*
*   topIndex = Index into data_dB of location of right-hand (larger angle)
*       bound of the beam
*
*   botIndex = Index into data_dB of location of left-hand (smaller angle)
*       bound of the beam
*
*   maxIndex = Index into data_dB of location of pattern maximum
*
*   beamwidthDepth_dB = Decrease between pattern max and bounds of
*       beam, e.g. set this to +3 for the half-power (-3dB) beamwidth if
*       data_dB is a power pattern.
*
*   data_dB = Antenna pattern data in dB. Note that whether this is a power
*       or field pattern will influence what value you want to use with
*       beamwidthDepth_dB. Data points are assumed to be given in strictly 
*       increasing or strictly decreasing order by angle.
*   
*   averagingWindowSize = Size, in data points, of moving average used to
*       smooth data before comparison to cutoff. If the average exceeds the
*       cutoff value, the beam edge is taken as the central point in the
*       window, rounded down (for both edges, thus neither shrinking nor
*       widening the beam, just potentially shifting it slightly). If not
*       specified, this value defaults to 4 data points.


SphToRect.m
*	Matlab function
*	[x, y, z] = SphToRect(r, theta, phi)
*	
*	Convert spherical coordinates (r, theta, phi) into rectangular (x, y, z)
*
*   r = radius from origin
*
*   theta = angle in radians from +z axis
*
*   phi = angle in radians from +x axis, in the XY plane
*
*   This function was written for easier conversion from spherical to
*   rectangular coordinates, since Matlab's built-in function sph2cart
*   uses an elevation angle instead of a zenith angle. Although this can be
*   handled with a simple conversion, i.e.
*       [x, y, z] = sph2cart(theta, (pi/2) - phi, r);
*   this function can allow for somewhat cleaner code (shorter arguments,
*   and in the order typically used for spherical coordinates).


test_findBeamwidth.m
*	Matlab script
*	
*	Generates a sample pattern (sin(phi/2))^2 for phi in [0,359], adds noise,
*	and plots the clean and noisy pattern in decibels. The beamwidth is
*	calculated and drawn on the noisy data graph. This is then repeated for the
*	same pattern rotated 120 degrees (with a fresh set of noise added to the
*	clean data).

